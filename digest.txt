Directory structure:
└── Kubis-Benchmark-website/
    ├── README.md
    ├── CLAUDE.md
    ├── index.html
    ├── main.py
    ├── pyproject.toml
    ├── .python-version
    ├── css/
    │   └── styles.css
    └── js/
        └── main.js

================================================
FILE: README.md
================================================
[Empty file]


================================================
FILE: CLAUDE.md
================================================
# Kubi's Benchmark Leaderboard - Project Documentation

## Overview

A static website for displaying LLM benchmark results. The site parses benchmark HTML files generated by an external benchmark runner and presents the data in sortable tables and charts.

## Tech Stack

| Technology | Purpose | CDN |
|------------|---------|-----|
| **Tailwind CSS** | Utility-first styling | `https://cdn.tailwindcss.com` |
| **Tabulator.js 6.3.0** | Interactive sortable/grouped tables | `https://unpkg.com/tabulator-tables@6.3.0` |
| **Chart.js 4.4.1** | Bar chart visualization | `https://cdn.jsdelivr.net/npm/chart.js@4.4.1` |
| **Vanilla JavaScript** | HTML parsing, application logic | N/A |

No build step required. All dependencies loaded via CDN.

## Project Structure

```
/
├── index.html                 # Main page with tabs and table containers
├── css/
│   └── styles.css             # Custom styles (medals, badges, Tabulator overrides)
├── js/
│   └── main.js                # Core application logic
├── data/
│   ├── runs.json              # Manifest listing available benchmark files
│   └── runs/                  # Directory containing benchmark HTML files
│       ├── performance_table_mock_extended.html
│       ├── performance_table_mock.html
│       └── performance_table_*.html
└── CLAUDE.md                  # This documentation file
```

## Data Format

### Benchmark HTML Structure

The site parses HTML files generated by the benchmark runner. Required structure:

```html
<table>
    <thead>
        <tr>
            <th rowspan="2">Question Index</th>
            <th rowspan="2">Points</th>
            <th colspan="3" class="model-header">model-name-1</th>
            <th colspan="3" class="model-header">model-name-2</th>
            <!-- More models... -->
        </tr>
        <tr>
            <th>Score</th><th>Tokens</th><th>Cost</th>
            <!-- Repeated for each model -->
        </tr>
    </thead>
    <tbody>
        <tr data-category="Category Name" data-subcategory="Subcategory Name">
            <td class="q-col">A1-J-question-description</td>
            <td>2</td>  <!-- Points for this question -->
            <td class="pass">PASS</td>  <!-- or "FAIL" or numeric like "0.5" -->
            <td class="tokens">1245</td>
            <td class="cost">$0.02</td>
            <!-- Repeated for each model -->
        </tr>
        <!-- More question rows... -->
    </tbody>
    <tfoot>
        <tr>
            <td colspan="2">TOTAL</td>
            <td class="score">36.75/41</td>
            <td class="tokens">27237</td>
            <td class="cost">$0.41</td>
            <!-- Repeated for each model -->
        </tr>
    </tfoot>
</table>
```

### Critical Data Attributes

- `data-category`: Category name (e.g., "Coding", "Reasoning", "STEM")
- `data-subcategory`: Subcategory name (e.g., "Leetcode", "Chess puzzle") - can be empty
- `class="model-header"`: Identifies model name headers
- `class="pass"` / `class="fail"`: Score cell classes (optional, text content is authoritative)

### Categories

The following categories are supported (in display order):

1. **Basic Mix**
   - Anti-Overfitting
   - Terminal Usage
   - Others

2. **Coding**
   - Leetcode
   - Competitive Gaming
   - Single HTML

3. **General Knowledge** (no subcategories)

4. **Reasoning**
   - Chess puzzle
   - Word puzzle
   - Pure Reasoning

5. **STEM**
   - Physics
   - Chemistry
   - Biology
   - Math

### Runs Manifest (`data/runs.json`)

```json
{
  "runs": [
    {
      "file": "performance_table_mock_extended.html",
      "date": "2026-01-21 16:00:00 (Extended Mock - 8 Models)"
    }
  ]
}
```

Update this file when adding new benchmark runs.

## Score Calculation

Scores are calculated consistently across all views (Model Rankings, Detailed Results, Chart):

| Score Type | Calculation |
|------------|-------------|
| **PASS** | Full question points (e.g., 2 points for a 2-point question) |
| **FAIL** | 0 points |
| **Numeric** (e.g., 0.5, 0.67) | Absolute value (0.5 means 0.5 points, NOT 50%) |

**Important**: The site calculates totals from individual question scores, NOT from the HTML footer totals. This ensures consistency across all views.

### Display Format

- Scores are displayed as `score/max` (e.g., "36.75/41")
- Scores are limited to 2 decimal places
- Category scores (Coding, Reasoning, STEM) shown in Model Rankings table

## Features

### 1. Model Rankings Tab

Main leaderboard table with columns:
- **Rank**: Auto-calculated with medal icons for top 3 (gold/silver/bronze)
- **Model**: Model name
- **Score**: Total score as `earned/max`
- **Total Tokens**: Sum of all tokens used
- **Total Cost**: Sum of all costs
- **Coding**: Category score
- **Reasoning**: Category score
- **STEM**: Category score

All columns are sortable. Models sorted by score (highest first) by default.

### 2. Detailed Results Tab

Grouped table showing per-question results:
- Grouped by Category > Subcategory (collapsible)
- Shows Question index (e.g., "A1", "A9"), Points
- Per-model columns: Score, Tokens, Cost
- Category totals at bottom of each category
- Grand total at bottom

Models are ordered left-to-right by score (highest on left).

Vertical separators between model sections for visual clarity.

### 3. Chart Tab

Bar chart visualization with category filter:
- **General (Total)**: Shows overall scores
- **Coding**: Shows only Coding category scores
- **Reasoning**: Shows only Reasoning category scores
- **STEM**: Shows only STEM category scores

Chart updates automatically when category is changed.

### 4. Run Selector

Dropdown to switch between different benchmark runs. Located in the controls section below the header.

## Styling

### Score Badges

| Class | Appearance | Usage |
|-------|------------|-------|
| `.score-pass` | Green badge | PASS results |
| `.score-fail` | Red badge | FAIL results |
| `.score-partial` | Yellow/amber badge | Partial scores |
| `.score-total` | Blue badge | Category/grand totals |

### Rank Medals

| Class | Appearance |
|-------|------------|
| `.rank-gold` | Gold gradient, rank 1 |
| `.rank-silver` | Silver gradient, rank 2 |
| `.rank-bronze` | Bronze gradient, rank 3 |
| `.rank-number` | Gray text, rank 4+ |

### Table Customizations

- No row separators (clean look)
- Vertical separators between model sections in detailed view
- Alternating row colors (white/light gray)
- Sticky headers
- Responsive with horizontal scroll on mobile

## Adding New Benchmark Runs

1. Generate benchmark HTML with your benchmark runner
2. Ensure HTML includes `data-category` and `data-subcategory` attributes on each `<tr>`
3. Place HTML file in `data/runs/` directory
4. Update `data/runs.json` manifest with new entry
5. Refresh the page

## Key Functions in `main.js`

| Function | Purpose |
|----------|---------|
| `init()` | Application entry point |
| `loadManifest()` | Fetches `runs.json` |
| `loadRun(filename)` | Loads and parses a benchmark HTML file |
| `parseHTML(html)` | Extracts models, questions, and results from HTML |
| `renderSummaryTable(data)` | Renders Model Rankings tab |
| `renderDetailTable(data)` | Renders Detailed Results tab |
| `renderChart(data)` | Renders Chart tab with category filtering |
| `scoreFormatter(cell)` | Formats score cells with appropriate badges |
| `rankFormatter(cell)` | Formats rank with medals |
| `formatScore(score)` | Limits score to 2 decimal places |

## Hosting

Designed for static hosting (GitHub Pages, Netlify, etc.). No server-side processing required.

Since JavaScript cannot scan directories on static hosting, the `data/runs.json` manifest must be manually updated when adding new benchmark files.

## Browser Support

Modern browsers with ES6+ support. Tested on:
- Chrome/Chromium
- Firefox
- Safari
- Edge

## Development

To run locally:

```bash
cd /path/to/project
python -m http.server 8000
# Open http://localhost:8000 in browser
```

A local HTTP server is required due to CORS restrictions when fetching local files.



================================================
FILE: index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kubi's Benchmark Leaderboard</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Tabulator CSS -->
    <link href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator_simple.min.css" rel="stylesheet">

    <!-- Custom styles -->
    <link href="css/styles.css" rel="stylesheet">
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-sm border-b border-gray-200">
        <div class="max-w-7xl mx-auto px-4 py-6">
            <h1 class="text-3xl font-bold text-gray-900">Kubi's Benchmark Leaderboard</h1>
            <p class="text-gray-500 mt-1">Comparing LLM performance across coding, reasoning, and knowledge tasks</p>
        </div>
    </header>

    <!-- Controls -->
    <div class="max-w-7xl mx-auto px-4 py-4">
        <div class="flex flex-wrap items-center gap-4 bg-white rounded-lg shadow-sm p-4 border border-gray-200">
            <div class="flex items-center gap-2">
                <label for="run-selector" class="text-sm font-medium text-gray-700">Benchmark Run:</label>
                <select id="run-selector" class="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm px-3 py-2 border">
                    <option value="">Loading runs...</option>
                </select>
            </div>
            <div class="text-sm text-gray-500" id="run-date"></div>
        </div>
    </div>

    <!-- Main content -->
    <main class="max-w-7xl mx-auto px-4 py-6">
        <!-- Tab Navigation -->
        <div class="border-b border-gray-200 mb-6">
            <nav class="flex space-x-8" aria-label="Tabs">
                <button class="tab-btn active" data-tab="rankings">
                    Model Rankings
                </button>
                <button class="tab-btn" data-tab="details">
                    Detailed Results
                </button>
                <button class="tab-btn" data-tab="chart">
                    Chart
                </button>
            </nav>
        </div>

        <!-- Tab: Model Rankings -->
        <section id="tab-rankings" class="tab-content active">
            <div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
                <div id="summary-table"></div>
            </div>
        </section>

        <!-- Tab: Detailed Results -->
        <section id="tab-details" class="tab-content hidden">
            <div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
                <div id="detail-table"></div>
            </div>
        </section>

        <!-- Tab: Chart -->
        <section id="tab-chart" class="tab-content hidden">
            <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
                <div class="flex items-center gap-4 mb-4">
                    <label for="chart-category" class="text-sm font-medium text-gray-700">Category:</label>
                    <select id="chart-category" class="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm px-3 py-2 border">
                        <option value="General" selected>General (Total)</option>
                        <option value="Coding">Coding</option>
                        <option value="Reasoning">Reasoning</option>
                        <option value="STEM">STEM</option>
                    </select>
                </div>
                <div style="height: 400px; position: relative;">
                    <canvas id="score-chart"></canvas>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="bg-white border-t border-gray-200 mt-12">
        <div class="max-w-7xl mx-auto px-4 py-6 text-center text-gray-500 text-sm">
            <p>Kubi's Benchmark - Evaluating LLM capabilities</p>
        </div>
    </footer>

    <!-- Tabulator JS -->
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <!-- Main application JS -->
    <script src="js/main.js"></script>
</body>
</html>



================================================
FILE: main.py
================================================
def main():
    print("Hello from kubis-benchmark-website!")


if __name__ == "__main__":
    main()



================================================
FILE: pyproject.toml
================================================
[project]
name = "kubis-benchmark-website"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "gitingest>=0.3.1",
]



================================================
FILE: .python-version
================================================
3.12



================================================
FILE: css/styles.css
================================================
/**
 * Custom styles for Kubi's Benchmark Leaderboard
 * Extends Tailwind CSS and Tabulator styling
 */

/* Tab Navigation */
.tab-btn {
    padding: 12px 4px;
    font-size: 14px;
    font-weight: 500;
    color: #6b7280;
    border-bottom: 2px solid transparent;
    transition: all 0.15s ease;
    cursor: pointer;
    background: none;
    border-top: none;
    border-left: none;
    border-right: none;
}

.tab-btn:hover {
    color: #374151;
    border-bottom-color: #d1d5db;
}

.tab-btn.active {
    color: #2563eb;
    border-bottom-color: #2563eb;
}

.tab-content {
    display: block;
}

.tab-content.hidden {
    display: none;
}

/* Rank medals */
.rank-medal {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-weight: bold;
    font-size: 14px;
}

.rank-gold {
    background: linear-gradient(135deg, #ffd700 0%, #ffec8b 50%, #ffd700 100%);
    color: #8b6914;
    box-shadow: 0 2px 4px rgba(255, 215, 0, 0.4);
}

.rank-silver {
    background: linear-gradient(135deg, #c0c0c0 0%, #e8e8e8 50%, #c0c0c0 100%);
    color: #5a5a5a;
    box-shadow: 0 2px 4px rgba(192, 192, 192, 0.4);
}

.rank-bronze {
    background: linear-gradient(135deg, #cd7f32 0%, #daa06d 50%, #cd7f32 100%);
    color: #5c3d1e;
    box-shadow: 0 2px 4px rgba(205, 127, 50, 0.4);
}

.rank-number {
    color: #6b7280;
    font-weight: 600;
}

/* Score badges */
.score-pass {
    display: inline-block;
    padding: 2px 10px;
    border-radius: 9999px;
    background-color: #d1fae5;
    color: #065f46;
    font-weight: 600;
    font-size: 13px;
}

.score-fail {
    display: inline-block;
    padding: 2px 10px;
    border-radius: 9999px;
    background-color: #fee2e2;
    color: #991b1b;
    font-weight: 600;
    font-size: 13px;
}

.score-partial {
    display: inline-block;
    padding: 2px 10px;
    border-radius: 9999px;
    background-color: #fef3c7;
    color: #92400e;
    font-weight: 600;
    font-size: 13px;
}

.score-total {
    display: inline-block;
    padding: 2px 10px;
    border-radius: 9999px;
    background-color: #e0e7ff;
    color: #3730a3;
    font-weight: 700;
    font-size: 13px;
}

/* Tabulator customizations */
.tabulator {
    border: none;
    font-size: 14px;
}

.tabulator .tabulator-tableholder {
    border: none;
}

.tabulator .tabulator-row .tabulator-cell {
    border: none !important;
}

.tabulator .tabulator-row {
    border: none !important;
}

.tabulator .tabulator-row.tabulator-group,
.tabulator .tabulator-row.tabulator-group:nth-child(even),
.tabulator .tabulator-row.tabulator-group:nth-child(odd) {
    border: none !important;
    border-top: none !important;
    border-bottom: none !important;
}

/* Vertical separators between model sections */
#detail-table .tabulator-col-group {
    border-left: 2px solid #d1d5db !important;
}

#detail-table .tabulator-cell[tabulator-field$="_score"] {
    border-left: 2px solid #d1d5db !important;
}

.tabulator .tabulator-header {
    background-color: #f9fafb;
    border-bottom: 2px solid #e5e7eb;
}

.tabulator .tabulator-header .tabulator-col {
    background-color: #f9fafb;
    border-right: none;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable:hover {
    background-color: #f3f4f6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
    padding: 12px 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-title {
    font-weight: 600;
    color: #374151;
}

.tabulator-row {
    border-bottom: none;
}

.tabulator-row:hover {
    background-color: #f9fafb !important;
}

.tabulator-row.tabulator-row-even {
    background-color: #ffffff;
}

.tabulator-row.tabulator-row-odd {
    background-color: #fafafa;
}

.tabulator .tabulator-cell {
    padding: 10px 8px;
    border-right: none;
}

/* Group headers for categories */
.tabulator .tabulator-row.tabulator-group {
    background-color: #f9fafb;
    color: #374151;
    font-weight: 600;
    border: none !important;
}

.tabulator .tabulator-row.tabulator-group:hover {
    background-color: #f3f4f6 !important;
}

/* Subcategory group styling */
.tabulator .tabulator-row.tabulator-group.tabulator-group-level-1 {
    background-color: #ffffff;
    padding-left: 20px;
}

.tabulator .tabulator-row.tabulator-group.tabulator-group-level-1:hover {
    background-color: #f9fafb !important;
}

/* Model name column */
.model-name {
    font-weight: 600;
    color: #1f2937;
}

.model-subtext {
    font-size: 12px;
    color: #9ca3af;
}

/* Tokens and cost styling */
.tokens-cell {
    color: #3b82f6;
    font-variant-numeric: tabular-nums;
}

.cost-cell {
    color: #f59e0b;
    font-variant-numeric: tabular-nums;
}

.efficiency-cell {
    color: #10b981;
    font-weight: 600;
    font-variant-numeric: tabular-nums;
}

/* Total score styling */
.total-score {
    font-weight: 700;
    color: #1f2937;
    font-size: 15px;
}

/* Question index styling */
.question-index {
    font-weight: 600;
    color: #4b5563;
    font-family: ui-monospace, monospace;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .tabulator .tabulator-cell {
        padding: 8px 4px;
        font-size: 13px;
    }

    .tabulator .tabulator-header .tabulator-col .tabulator-col-content {
        padding: 10px 4px;
    }

    .rank-medal {
        width: 24px;
        height: 24px;
        font-size: 12px;
    }
}

/* Loading state */
.loading-spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 2px solid #e5e7eb;
    border-top-color: #3b82f6;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

/* Points column */
.points-cell {
    font-weight: 600;
    color: #6366f1;
}



================================================
FILE: js/main.js
================================================
/**
 * Main application logic for Kubi's Benchmark Leaderboard
 * Handles HTML parsing, table initialization, and run selection
 */

// Global state
let summaryTable = null;
let detailTable = null;
let scoreChart = null;
let currentData = null;

// Category display order
const CATEGORY_ORDER = [
    'Basic Mix',
    'Coding',
    'General Knowledge',
    'Reasoning',
    'STEM'
];

/**
 * Initialize the application
 */
async function init() {
    try {
        initTabs();
        initChartCategorySelector();
        const manifest = await loadManifest();
        populateRunSelector(manifest.runs);

        if (manifest.runs.length > 0) {
            await loadRun(manifest.runs[0].file);
        }
    } catch (error) {
        console.error('Failed to initialize:', error);
        showError('Failed to load benchmark data. Please check the console for details.');
    }
}

/**
 * Initialize chart category selector
 */
function initChartCategorySelector() {
    const selector = document.getElementById('chart-category');
    if (selector) {
        selector.addEventListener('change', () => {
            if (currentData) {
                renderChart(currentData);
            }
        });
    }
}

/**
 * Initialize tab navigation
 */
function initTabs() {
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');

    tabButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            const targetTab = btn.dataset.tab;

            // Update button states
            tabButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Update content visibility
            tabContents.forEach(content => {
                if (content.id === `tab-${targetTab}`) {
                    content.classList.remove('hidden');
                    content.classList.add('active');
                } else {
                    content.classList.add('hidden');
                    content.classList.remove('active');
                }
            });

            // Re-render chart when tab becomes visible (Chart.js sizing issue)
            if (targetTab === 'chart' && currentData) {
                renderChart(currentData);
            }

        });
    });
}

/**
 * Load the runs manifest
 */
async function loadManifest() {
    const response = await fetch('data/runs.json');
    if (!response.ok) {
        throw new Error(`Failed to load manifest: ${response.status}`);
    }
    return response.json();
}

/**
 * Populate the run selector dropdown
 */
function populateRunSelector(runs) {
    const selector = document.getElementById('run-selector');
    selector.innerHTML = '';

    runs.forEach((run, index) => {
        const option = document.createElement('option');
        option.value = run.file;
        option.textContent = run.date;
        if (index === 0) option.selected = true;
        selector.appendChild(option);
    });

    selector.addEventListener('change', async (e) => {
        if (e.target.value) {
            await loadRun(e.target.value);
        }
    });
}

/**
 * Load and parse a benchmark run HTML file
 */
async function loadRun(filename) {
    try {
        const response = await fetch(`data/runs/${filename}`);
        if (!response.ok) {
            throw new Error(`Failed to load run: ${response.status}`);
        }

        const html = await response.text();
        currentData = parseHTML(html);

        updateRunDate(filename);
        renderSummaryTable(currentData);
        renderDetailTable(currentData);
        renderChart(currentData);
    } catch (error) {
        console.error('Failed to load run:', error);
        showError(`Failed to load benchmark run: ${filename}`);
    }
}

/**
 * Update the displayed run date
 */
function updateRunDate(filename) {
    const match = filename.match(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})/);
    if (match) {
        const [, year, month, day, hour, min, sec] = match;
        const dateStr = `${year}-${month}-${day} ${hour}:${min}:${sec}`;
        document.getElementById('run-date').textContent = `Run: ${dateStr}`;
    }
}

/**
 * Parse benchmark HTML and extract data
 */
function parseHTML(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');

    // Extract model names from header
    const modelHeaders = doc.querySelectorAll('th.model-header, th[class*="model-header"]');
    const models = Array.from(modelHeaders).map(th => th.textContent.trim());

    // If no model-header class, try to find headers with colspan="3"
    if (models.length === 0) {
        const colspanHeaders = doc.querySelectorAll('thead tr:first-child th[colspan="3"]');
        colspanHeaders.forEach(th => models.push(th.textContent.trim()));
    }

    // Extract question data from tbody rows
    const questions = [];
    const rows = doc.querySelectorAll('tbody tr');

    rows.forEach(row => {
        const category = row.dataset.category || 'Uncategorized';
        const subcategory = row.dataset.subcategory || '';

        const cells = row.querySelectorAll('td');
        if (cells.length < 2) return;

        // First cell is question index (e.g., "A5-V-terminal-unzip")
        const questionFull = cells[0].textContent.trim();
        const questionIndex = extractQuestionIndex(questionFull);

        // Second cell is points
        const points = parseFloat(cells[1].textContent.trim()) || 0;

        // Remaining cells are model results (3 per model: score, tokens, cost)
        const modelResults = {};
        let cellIndex = 2;

        models.forEach(model => {
            if (cellIndex + 2 < cells.length) {
                const scoreCell = cells[cellIndex];
                const tokensCell = cells[cellIndex + 1];
                const costCell = cells[cellIndex + 2];

                modelResults[model] = {
                    score: parseScore(scoreCell),
                    scoreRaw: scoreCell.textContent.trim(),
                    scoreClass: getScoreClass(scoreCell),
                    tokens: parseTokens(tokensCell.textContent.trim()),
                    cost: parseCost(costCell.textContent.trim())
                };

                cellIndex += 3;
            }
        });

        questions.push({
            index: questionIndex,
            fullName: questionFull,
            points,
            category,
            subcategory,
            results: modelResults
        });
    });

    // Extract totals from tfoot
    const totals = {};
    const tfootCells = doc.querySelectorAll('tfoot td');

    if (tfootCells.length > 2) {
        let cellIndex = 2; // Skip first two cells (colspan label)
        models.forEach(model => {
            if (cellIndex + 2 < tfootCells.length) {
                totals[model] = {
                    score: tfootCells[cellIndex].textContent.trim(),
                    tokens: parseTokens(tfootCells[cellIndex + 1].textContent.trim()),
                    cost: parseCost(tfootCells[cellIndex + 2].textContent.trim())
                };
                cellIndex += 3;
            }
        });
    }

    return { models, questions, totals };
}

/**
 * Extract question index (e.g., "A5" from "A5-V-terminal-unzip")
 */
function extractQuestionIndex(fullName) {
    const match = fullName.match(/^(A\d+)/i);
    return match ? match[1] : fullName;
}

/**
 * Parse score value from cell
 */
function parseScore(cell) {
    const text = cell.textContent.trim().toUpperCase();
    if (text === 'PASS') return 1;
    if (text === 'FAIL') return 0;
    return parseFloat(text) || 0;
}

/**
 * Get score class for styling
 */
function getScoreClass(cell) {
    const text = cell.textContent.trim().toUpperCase();
    if (text === 'PASS' || cell.classList.contains('pass')) return 'pass';
    if (text === 'FAIL' || cell.classList.contains('fail')) return 'fail';
    return 'partial';
}

/**
 * Parse tokens string to number
 */
function parseTokens(str) {
    return parseInt(str.replace(/[^0-9]/g, ''), 10) || 0;
}

/**
 * Parse cost string to number
 */
function parseCost(str) {
    const match = str.match(/[\d.]+/);
    return match ? parseFloat(match[0]) : 0;
}

/**
 * Render the summary/leaderboard table
 */
function renderSummaryTable(data) {
    // Calculate category scores for each model
    const categoryScores = {};
    const categoryMaxScores = {};

    // Calculate max score for all questions
    const totalMaxScore = data.questions.reduce((sum, q) => sum + q.points, 0);

    ['Coding', 'Reasoning', 'STEM'].forEach(category => {
        categoryMaxScores[category] = data.questions
            .filter(q => q.category === category)
            .reduce((sum, q) => sum + q.points, 0);
    });

    // Calculate scores for each model
    const modelTotalScores = {};
    data.models.forEach(model => {
        categoryScores[model] = {};

        // Calculate total score from all questions
        modelTotalScores[model] = data.questions.reduce((sum, q) => {
            const result = q.results[model];
            if (!result) return sum;
            if (result.scoreClass === 'pass') return sum + q.points;
            if (result.scoreClass === 'fail') return sum;
            return sum + (result.score || 0);
        }, 0);

        // Calculate category scores
        ['Coding', 'Reasoning', 'STEM'].forEach(category => {
            const categoryQuestions = data.questions.filter(q => q.category === category);
            const score = categoryQuestions.reduce((sum, q) => {
                const result = q.results[model];
                if (!result) return sum;
                if (result.scoreClass === 'pass') return sum + q.points;
                if (result.scoreClass === 'fail') return sum;
                return sum + (result.score || 0);
            }, 0);
            categoryScores[model][category] = score;
        });
    });

    const tableData = data.models.map((model, index) => {
        const total = data.totals[model] || {};
        const scoreNum = modelTotalScores[model] || 0;
        const tokens = total.tokens || 0;
        const cost = total.cost || 0;

        return {
            rank: index + 1,
            model: model,
            score: `${formatScore(scoreNum)}/${totalMaxScore}`,
            scoreNum: scoreNum,
            tokens: tokens,
            cost: cost,
            codingScore: categoryScores[model]['Coding'] || 0,
            codingMax: categoryMaxScores['Coding'] || 0,
            reasoningScore: categoryScores[model]['Reasoning'] || 0,
            reasoningMax: categoryMaxScores['Reasoning'] || 0,
            stemScore: categoryScores[model]['STEM'] || 0,
            stemMax: categoryMaxScores['STEM'] || 0
        };
    });

    // Sort by score descending
    tableData.sort((a, b) => b.scoreNum - a.scoreNum);

    // Update ranks after sorting
    tableData.forEach((row, index) => {
        row.rank = index + 1;
    });

    if (summaryTable) {
        summaryTable.replaceData(tableData);
    } else {
        summaryTable = new Tabulator('#summary-table', {
            data: tableData,
            layout: 'fitColumns',
            responsiveLayout: 'collapse',
            columns: [
                {
                    title: 'Rank',
                    field: 'rank',
                    width: 80,
                    hozAlign: 'center',
                    formatter: rankFormatter
                },
                {
                    title: 'Model',
                    field: 'model',
                    minWidth: 200,
                    formatter: modelFormatter
                },
                {
                    title: 'Score',
                    field: 'score',
                    width: 120,
                    hozAlign: 'center',
                    sorter: 'number',
                    sorterParams: { alignEmptyValues: 'bottom' },
                    formatter: (cell) => `<span class="total-score">${cell.getValue()}</span>`
                },
                {
                    title: 'Total Tokens',
                    field: 'tokens',
                    width: 130,
                    hozAlign: 'right',
                    sorter: 'number',
                    formatter: (cell) => `<span class="tokens-cell">${cell.getValue().toLocaleString()}</span>`
                },
                {
                    title: 'Total Cost',
                    field: 'cost',
                    width: 120,
                    hozAlign: 'right',
                    sorter: 'number',
                    formatter: (cell) => `<span class="cost-cell">$${cell.getValue().toFixed(2)}</span>`
                },
                {
                    title: 'Coding',
                    field: 'codingScore',
                    width: 100,
                    hozAlign: 'center',
                    sorter: 'number',
                    formatter: (cell) => {
                        const row = cell.getRow().getData();
                        return `<span class="score-partial">${formatScore(row.codingScore)}/${row.codingMax}</span>`;
                    }
                },
                {
                    title: 'Reasoning',
                    field: 'reasoningScore',
                    width: 110,
                    hozAlign: 'center',
                    sorter: 'number',
                    formatter: (cell) => {
                        const row = cell.getRow().getData();
                        return `<span class="score-partial">${formatScore(row.reasoningScore)}/${row.reasoningMax}</span>`;
                    }
                },
                {
                    title: 'STEM',
                    field: 'stemScore',
                    width: 100,
                    hozAlign: 'center',
                    sorter: 'number',
                    formatter: (cell) => {
                        const row = cell.getRow().getData();
                        return `<span class="score-partial">${formatScore(row.stemScore)}/${row.stemMax}</span>`;
                    }
                }
            ],
            initialSort: [{ column: 'scoreNum', dir: 'desc' }]
        });
    }
}

/**
 * Parse total score string to number (e.g., "36.75/41" -> 36.75)
 */
function parseScoreTotal(scoreStr) {
    if (!scoreStr) return 0;
    const match = scoreStr.match(/([\d.]+)/);
    return match ? parseFloat(match[1]) : 0;
}

/**
 * Format score to max 2 decimal places (removes trailing zeros)
 */
function formatScore(score) {
    if (Number.isInteger(score)) return score.toString();
    const rounded = Math.round(score * 100) / 100;
    return rounded.toString();
}

/**
 * Format rank with medals
 */
function rankFormatter(cell) {
    const rank = cell.getValue();
    if (rank === 1) {
        return `<span class="rank-medal rank-gold">1</span>`;
    } else if (rank === 2) {
        return `<span class="rank-medal rank-silver">2</span>`;
    } else if (rank === 3) {
        return `<span class="rank-medal rank-bronze">3</span>`;
    }
    return `<span class="rank-number">${rank}</span>`;
}

/**
 * Format model name
 */
function modelFormatter(cell) {
    const model = cell.getValue();
    return `<span class="model-name">${model}</span>`;
}

/**
 * Render the detailed results table
 */
function renderDetailTable(data) {
    // Calculate actual scores from questions for sorting
    const modelScores = {};
    data.models.forEach(model => {
        modelScores[model] = data.questions.reduce((sum, q) => {
            const result = q.results[model];
            if (!result) return sum;
            const scoreClass = result.scoreClass;
            if (scoreClass === 'pass') return sum + q.points;
            if (scoreClass === 'fail') return sum;
            return sum + (result.score || 0);
        }, 0);
    });

    // Sort models by score (highest first)
    const sortedModels = [...data.models].sort((a, b) => {
        return modelScores[b] - modelScores[a];
    });

    // Build columns dynamically based on models
    const columns = [
        {
            title: 'Question',
            field: 'index',
            width: 100,
            frozen: true,
            headerSort: false,
            formatter: (cell) => `<span class="question-index">${cell.getValue()}</span>`
        },
        {
            title: 'Points',
            field: 'points',
            width: 80,
            hozAlign: 'center',
            headerSort: false,
            formatter: (cell) => `<span class="points-cell">${cell.getValue()}</span>`
        }
    ];

    // Add columns for each model (sorted by score, highest first)
    sortedModels.forEach(model => {
        columns.push({
            title: model,
            columns: [
                {
                    title: 'Score',
                    field: `${model}_score`,
                    width: 90,
                    hozAlign: 'center',
                    headerSort: false,
                    formatter: scoreFormatter
                },
                {
                    title: 'Tokens',
                    field: `${model}_tokens`,
                    width: 90,
                    hozAlign: 'right',
                    headerSort: false,
                    formatter: (cell) => `<span class="tokens-cell">${cell.getValue().toLocaleString()}</span>`
                },
                {
                    title: 'Cost',
                    field: `${model}_cost`,
                    width: 80,
                    hozAlign: 'right',
                    headerSort: false,
                    formatter: (cell) => `<span class="cost-cell">$${cell.getValue().toFixed(2)}</span>`
                }
            ]
        });
    });

    // Transform question data to flat rows
    const tableData = data.questions.map(q => {
        const row = {
            index: q.index,
            points: q.points,
            category: q.category,
            subcategory: q.subcategory || '(none)',
            _categoryOrder: CATEGORY_ORDER.indexOf(q.category),
            _isTotal: false
        };

        data.models.forEach(model => {
            const result = q.results[model] || {};
            row[`${model}_score`] = result.score || 0;
            row[`${model}_scoreRaw`] = result.scoreRaw || '0';
            row[`${model}_scoreClass`] = result.scoreClass || 'fail';
            row[`${model}_tokens`] = result.tokens || 0;
            row[`${model}_cost`] = result.cost || 0;
        });

        return row;
    });

    // Sort by category order, then subcategory, then index
    tableData.sort((a, b) => {
        if (a._categoryOrder !== b._categoryOrder) {
            return a._categoryOrder - b._categoryOrder;
        }
        if (a.subcategory !== b.subcategory) {
            return a.subcategory.localeCompare(b.subcategory);
        }
        return a.index.localeCompare(b.index);
    });

    // Calculate and add category totals
    CATEGORY_ORDER.forEach(category => {
        const categoryQuestions = tableData.filter(q => q.category === category && !q._isTotal);
        if (categoryQuestions.length === 0) return;

        const totalRow = {
            index: 'Total',
            points: categoryQuestions.reduce((sum, q) => sum + q.points, 0),
            category: category,
            subcategory: 'zzz_Total', // zzz to sort last
            _categoryOrder: CATEGORY_ORDER.indexOf(category),
            _isTotal: true
        };

        sortedModels.forEach(model => {
            // PASS = full points, FAIL = 0, numeric = absolute value
            const totalScore = categoryQuestions.reduce((sum, q) => {
                const scoreClass = q[`${model}_scoreClass`];
                if (scoreClass === 'pass') return sum + q.points;
                if (scoreClass === 'fail') return sum + 0;
                // Partial score - use the raw numeric value
                return sum + (q[`${model}_score`] || 0);
            }, 0);
            const totalTokens = categoryQuestions.reduce((sum, q) => sum + (q[`${model}_tokens`] || 0), 0);
            const totalCost = categoryQuestions.reduce((sum, q) => sum + (q[`${model}_cost`] || 0), 0);
            const maxScore = categoryQuestions.reduce((sum, q) => sum + q.points, 0);

            totalRow[`${model}_score`] = totalScore;
            totalRow[`${model}_scoreRaw`] = `${formatScore(totalScore)}/${maxScore}`;
            totalRow[`${model}_scoreClass`] = 'total';
            totalRow[`${model}_tokens`] = totalTokens;
            totalRow[`${model}_cost`] = totalCost;
        });

        tableData.push(totalRow);
    });

    // Add grand total row
    const allQuestions = tableData.filter(q => !q._isTotal);
    const grandTotalRow = {
        index: 'TOTAL',
        points: allQuestions.reduce((sum, q) => sum + q.points, 0),
        category: 'zzz_Grand Total', // zzz to sort last
        subcategory: '',
        _categoryOrder: 999,
        _isTotal: true
    };

    sortedModels.forEach(model => {
        // PASS = full points, FAIL = 0, numeric = absolute value
        const totalScore = allQuestions.reduce((sum, q) => {
            const scoreClass = q[`${model}_scoreClass`];
            if (scoreClass === 'pass') return sum + q.points;
            if (scoreClass === 'fail') return sum + 0;
            // Partial score - use the raw numeric value
            return sum + (q[`${model}_score`] || 0);
        }, 0);
        const totalTokens = allQuestions.reduce((sum, q) => sum + (q[`${model}_tokens`] || 0), 0);
        const totalCost = allQuestions.reduce((sum, q) => sum + (q[`${model}_cost`] || 0), 0);
        const maxScore = allQuestions.reduce((sum, q) => sum + q.points, 0);

        grandTotalRow[`${model}_score`] = totalScore;
        grandTotalRow[`${model}_scoreRaw`] = `${formatScore(totalScore)}/${maxScore}`;
        grandTotalRow[`${model}_scoreClass`] = 'total';
        grandTotalRow[`${model}_tokens`] = totalTokens;
        grandTotalRow[`${model}_cost`] = totalCost;
    });

    tableData.push(grandTotalRow);

    // Re-sort to include totals in correct positions
    tableData.sort((a, b) => {
        if (a._categoryOrder !== b._categoryOrder) {
            return a._categoryOrder - b._categoryOrder;
        }
        if (a.subcategory !== b.subcategory) {
            return a.subcategory.localeCompare(b.subcategory);
        }
        return a.index.localeCompare(b.index);
    });

    // Destroy and recreate table to handle column reordering
    if (detailTable) {
        detailTable.destroy();
    }

    detailTable = new Tabulator('#detail-table', {
            data: tableData,
            layout: 'fitDataFill',
            groupBy: ['category', 'subcategory'],
            groupStartOpen: [true, true],
            groupHeader: (value, count, data, group) => {
                const level = group.getParentGroup() ? 1 : 0;
                // Handle special total category
                if (value === 'zzz_Grand Total') {
                    return `<span style="font-weight: 700;">Grand Total</span>`;
                }
                if (level === 0) {
                    return `<span style="font-weight: 600;">${value}</span> <span style="opacity: 0.7; margin-left: 8px;">(${count} questions)</span>`;
                }
                // Handle subcategory totals
                if (value === 'zzz_Total') {
                    return `<span style="font-weight: 600; padding-left: 10px;">Category Total</span>`;
                }
                return `<span style="font-weight: 500; padding-left: 10px;">${value === '(none)' ? 'General' : value}</span> <span style="opacity: 0.7; margin-left: 8px;">(${count})</span>`;
            },
            columns: columns,
            columnDefaults: {
                headerSort: false,
                headerHozAlign: 'center'
            }
        });
}

/**
 * Render the bar chart showing model scores
 */
function renderChart(data) {
    const ctx = document.getElementById('score-chart');
    if (!ctx) return;

    // Get selected category
    const categorySelector = document.getElementById('chart-category');
    const selectedCategory = categorySelector ? categorySelector.value : 'General';

    // Prepare chart data - calculate scores based on selected category
    const chartData = data.models.map(model => {
        let score = 0;
        let maxScore = 0;

        // Filter questions by category (or all for General)
        const questions = selectedCategory === 'General'
            ? data.questions
            : data.questions.filter(q => q.category === selectedCategory);

        maxScore = questions.reduce((sum, q) => sum + q.points, 0);
        score = questions.reduce((sum, q) => {
            const result = q.results[model];
            if (!result) return sum;
            if (result.scoreClass === 'pass') return sum + q.points;
            if (result.scoreClass === 'fail') return sum;
            return sum + (result.score || 0);
        }, 0);

        return {
            model: model,
            score: score,
            maxScore: maxScore
        };
    }).sort((a, b) => b.score - a.score);

    const labels = chartData.map(d => d.model);
    const scores = chartData.map(d => d.score);

    // Generate colors - gradient from best to worst
    const colors = generateBarColors(scores.length);

    // Destroy existing chart if any
    if (scoreChart) {
        scoreChart.destroy();
    }

    scoreChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Score',
                data: scores,
                backgroundColor: colors,
                borderColor: colors.map(c => adjustColorBrightness(c, -20)),
                borderWidth: 1,
                borderRadius: 4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'x',
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        label: (context) => `Score: ${context.raw.toFixed(2)}`
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    grid: {
                        color: '#f3f4f6'
                    },
                    ticks: {
                        font: {
                            size: 12
                        }
                    }
                },
                x: {
                    grid: {
                        display: false
                    },
                    ticks: {
                        font: {
                            size: 11
                        },
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            }
        }
    });
}

/**
 * Generate gradient colors for bar chart (similar to example)
 */
function generateBarColors(count) {
    const colors = [];
    // Start with muted teal/olive tones like the example
    const baseHues = [160, 50, 45, 40, 35]; // Teal to olive/tan gradient

    for (let i = 0; i < count; i++) {
        const progress = i / Math.max(count - 1, 1);
        // Interpolate between teal (160) and tan/gray (40)
        const hue = 160 - (progress * 120);
        const saturation = 25 - (progress * 10); // Decrease saturation
        const lightness = 45 + (progress * 20); // Increase lightness (lighter grays)
        colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
    }
    return colors;
}

/**
 * Adjust color brightness
 */
function adjustColorBrightness(color, amount) {
    // For HSL colors, adjust lightness
    const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
    if (match) {
        const h = parseInt(match[1]);
        const s = parseInt(match[2]);
        const l = Math.max(0, Math.min(100, parseInt(match[3]) + amount));
        return `hsl(${h}, ${s}%, ${l}%)`;
    }
    return color;
}

/**
 * Format score cell with badge
 */
function scoreFormatter(cell) {
    const row = cell.getRow().getData();
    const field = cell.getField();
    const modelName = field.replace('_score', '');
    const rawValue = row[`${modelName}_scoreRaw`];
    const scoreClass = row[`${modelName}_scoreClass`];

    if (scoreClass === 'total') {
        return `<span class="score-total">${rawValue}</span>`;
    } else if (scoreClass === 'pass') {
        return `<span class="score-pass">PASS</span>`;
    } else if (scoreClass === 'fail') {
        return `<span class="score-fail">FAIL</span>`;
    } else {
        // Format partial score to max 2 decimal places
        const numValue = parseFloat(rawValue);
        const formatted = isNaN(numValue) ? rawValue : formatScore(numValue);
        return `<span class="score-partial">${formatted}</span>`;
    }
}

/**
 * Show error message to user
 */
function showError(message) {
    const main = document.querySelector('main');
    const errorDiv = document.createElement('div');
    errorDiv.className = 'bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-4';
    errorDiv.textContent = message;
    main.insertBefore(errorDiv, main.firstChild);
}

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', init);


